---
date: 2016-12-30 11:20
status: public
title: 正则
---

* 什么是正则？
    > 是一种用来检测或者是匹配符合某个语法规范的字符串的语言。
* 正则式用来做什么的
    > 用于登录注册的验证
    > 敏感字符的检测等
    
**创建方式**
**字面量、实例化函数**
* var reg=/ /;
* var reg=new RegExp("定界符","模式修正符");
    * 定界符
    * 模式修正符有三个: i m g   gim(规范写法)
        * g 全局匹配
```javascript
//创建方式	
		var reg=/ /;
		var reg=new RegExp();
		var reg=/a/g
		var reg=new RegExp("aa","g");
```

**两种方法**
* test()  加全局匹配g，没有影响
    * 检测成功返回true  失败返回false
* exec()  加g会有影响，会影响【正则对象】的lastIndex属性
    * 检测成功
        *  0 检测到的字符 
        *  index 检测到字符的开始下标
        *  input 检测的字符串
    * 检测失败 Null
* lastIndex  【正则对象的】--正则下一次检测或者是匹配开始的位置--全局检测(加g)的情况下
    
**原子--定界符**
> 是构成正则表达式的最小单位。包含字母、数字等符号。
在正则里，一切皆原子。
* \d 匹配0-9里面的任意一个字符
* \w 匹配数字、字母、下划线
* \s 匹配任意一个空白字符
    * \n换行 \t制表符 \r回车 \f换页 \v垂直制表符 空格
* \D 匹配除了0-9里面的任意一个字符
* \W 匹配除了数字、字母、下划线之外的所有字符
* \S 匹配除了空白字符之外的所有字符
* \ 转义字符
* . 匹配除了换行以外的所有字符

**原子表**
```javascript
[]原子表
^非 
|或者
		var str="abcd1234";
	//同时满足\w和[1-2]
		var reg=/\w[1-2]/;
	//匹配a或b或c或d
		var reg=/[abcd]/;
	//匹配不是1-2的所有字符
		var reg=/[^1-2]/;
		var reg=/ab|cd/
		console.log(reg.exec(str));
```
**元字符**
> 正则里表示特殊意义的字符 / | [] g () ? :

**原子分组**
> ()将一些字符用括号括起来
1.提高优先级 2.形成原子分组
作用：会将括号当中匹配到的值压入内存以便调用(反向引用)。同时也会将括号中匹配到的值输出。
反向引用
取消反向引用: 在括号引用里加?: 不会被压入内存，只是提高 优先级

```javascript
原子分组
		var str="abc123";
	//()提高优先级 形成原子分组--将括号中匹配到的值压入内存并输出
		var reg1=/abc\d|adc\d/;
		var reg=/a(b|d)c\d/;
		console.log(reg1.exec(str));
		console.log(reg.exec(str));
		
		var str="1abcd1a23ad";
	//反向引用：将括号中匹配到的值压入内存并输出
		var reg=/(\d)abcd\1/;
	//取消反向引用：在括号引用里加?:
		var reg=/(?:\d)abcd/;
		console.log(reg.exec(str));
```

**量词--作用于前面的字符**
* 贪婪匹配 正则总是尽可能多的去匹配
* 吝啬匹配 量词后面加? 但是要保证表达式能匹配成功
    * {m} m次
    * {m,n} m到n次
    * {m,}  最少m次
    * * 匹配0次或者是多次--任意次 {0,}
    * ? 匹配0次或者1次--<=1   {0,1}
    * + 匹配1次或者是多次-->=1  {1,}
```javascript
量词
		var str="423a2bcd423acdg";
	//贪婪匹配
		var reg=/\d+abcd\d+/;
		var reg=/\d+abcd\d{2,5}/;
	//吝啬匹配--保证表达式能匹配成功
		var reg=/\d+?abcd\d+/;
		var reg=/\d+?bcd\d/;
		console.log(reg.exec(str));  
```    
**边界符**
* ^ 开头
* $ 结尾
* g 全局匹配
* i 忽略大小写
* m 多行匹配
* \b\b 单词匹配 将要匹配的单词包起来

**字符串**
* split()  加g不加g无影响
* replace() 支持全局匹配
* search()  
    * 不支持全局匹配
    * 是用来匹配指定字符或者是正则
    * 返回匹配到的字符首次出现的下标
    * 匹配不成功返回-1
* match()
    * 支持全局匹配
    * 不加g
        * 和exec的输出结果是一样的
    * 加g
        * 返回值为所有匹配到的值组成的数组